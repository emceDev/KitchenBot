# connecto to wifi DONE
# connect to Node server DONE
# download machine data DONE
#CREATE MOCK PYTHON SERVER? AND MOCK PYTHON CLIENTS TO SET AND TEST DONE
# get the receipe DONE
    #parse receipe to a schedule - mock it for now
#initialize websockets with esps
    #SRV: set job status on server
    #WS: pass job to esp
        #wait for status
    #

import asyncio
import websockets
from modules.data_handler import load_data
import json
import time

machine=load_data('./data/testData.json')

jobs= machine['receipes'][0]['jobs']
class Client:
    def __init__(self, websocket,data):
        self.websocket=websocket
        self.data=data


clients = {}
needed = 2
provided =0

async def send_message(code,client,data=None):
    # print('semnd massegae')
    # print(client.data['identifier'])
    ws_message={
        "code":code,
        "identifier":client.data['identifier'],
        "data":data
    }
    await client.websocket.send(json.dumps(ws_message))

async def run_jobs():
    global clients
    # Map jobs
    # job_type == add => map utils => if util.status idle?send job
    for job in jobs:
        print('searching for free utility for job')
        jobType=job['jobType']
       
        for client_number, client in clients.items():
            # print(client.data)
            if jobType in client.data['job_types'] and client.data['status']=='idle':
                return await initializeJob(client,job)

async def initializeJob(client,job):
    print('sendinging job to client')
    if job['jobType']=='add':
        await send_message('RNJ',client,job)


async def if_can_run():
    global provided
    global needed
    provided=provided+2
    print('if can run')
    if provided==needed:
        print('running jobs')
        await run_jobs()
    else:
        print('not enough tools, containers or utilities')

async def handle_client(websocket, client_number):
    global clients
    print(f"Client connected with number: {client_number}")
  
    ws_data = await websocket.recv()
    ws_data = json.loads(ws_data)
    print(ws_data)
    clients[ws_data['identifier']]= Client(websocket,ws_data['utility_data'])
    await if_can_run()
    try:
        # Continuously listen for messages from the client
        async for message in websocket:
            print(f"Received message from {client_number}: {message}")
            # message()
            # Echo the received message back to the client
            # await websocket.send(message)
    except websockets.exceptions.ConnectionClosedOK:
        # Remove the client from the dictionary when the connection is closed
        del clients[websocket]
        print(f"Client {client_number} disconnected")



async def main():
    # Start the websocket server
    async with websockets.serve(handle_client, "localhost", 8765):
        # Keep the server running indefinitely 
        await asyncio.Future()
        
# Run the main coroutine
asyncio.run(main())

